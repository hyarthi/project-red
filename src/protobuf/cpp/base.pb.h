// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base.proto

#ifndef PROTOBUF_base_2eproto__INCLUDED
#define PROTOBUF_base_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "notes.pb.h"
// @@protoc_insertion_point(includes)

namespace red {
namespace hooks {
namespace messages {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_base_2eproto();
void protobuf_InitDefaults_base_2eproto();
void protobuf_AssignDesc_base_2eproto();
void protobuf_ShutdownFile_base_2eproto();

class Request;
class Response;

// ===================================================================

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:red.hooks.messages.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum PayloadCase {
    kNoteInfo = 2,
    kNote = 3,
    kNcollection = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static const Response* internal_default_instance();

  void UnsafeArenaSwap(Response* other);
  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  void UnsafeMergeFrom(const Response& from);
  protected:
  explicit Response(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // optional .red.hooks.messages.NoteInfo noteInfo = 2;
  bool has_noteinfo() const;
  void clear_noteinfo();
  static const int kNoteInfoFieldNumber = 2;
  private:
  void _slow_mutable_noteinfo();
  void _slow_set_allocated_noteinfo(
      ::google::protobuf::Arena* message_arena, ::red::hooks::messages::NoteInfo** noteinfo);
  ::red::hooks::messages::NoteInfo* _slow_release_noteinfo();
  public:
  const ::red::hooks::messages::NoteInfo& noteinfo() const;
  ::red::hooks::messages::NoteInfo* mutable_noteinfo();
  ::red::hooks::messages::NoteInfo* release_noteinfo();
  void set_allocated_noteinfo(::red::hooks::messages::NoteInfo* noteinfo);
  ::red::hooks::messages::NoteInfo* unsafe_arena_release_noteinfo();
  void unsafe_arena_set_allocated_noteinfo(
      ::red::hooks::messages::NoteInfo* noteinfo);

  // optional .red.hooks.messages.Note note = 3;
  bool has_note() const;
  void clear_note();
  static const int kNoteFieldNumber = 3;
  private:
  void _slow_mutable_note();
  void _slow_set_allocated_note(
      ::google::protobuf::Arena* message_arena, ::red::hooks::messages::Note** note);
  ::red::hooks::messages::Note* _slow_release_note();
  public:
  const ::red::hooks::messages::Note& note() const;
  ::red::hooks::messages::Note* mutable_note();
  ::red::hooks::messages::Note* release_note();
  void set_allocated_note(::red::hooks::messages::Note* note);
  ::red::hooks::messages::Note* unsafe_arena_release_note();
  void unsafe_arena_set_allocated_note(
      ::red::hooks::messages::Note* note);

  // optional .red.hooks.messages.NoteCollection ncollection = 4;
  bool has_ncollection() const;
  void clear_ncollection();
  static const int kNcollectionFieldNumber = 4;
  private:
  void _slow_mutable_ncollection();
  void _slow_set_allocated_ncollection(
      ::google::protobuf::Arena* message_arena, ::red::hooks::messages::NoteCollection** ncollection);
  ::red::hooks::messages::NoteCollection* _slow_release_ncollection();
  public:
  const ::red::hooks::messages::NoteCollection& ncollection() const;
  ::red::hooks::messages::NoteCollection* mutable_ncollection();
  ::red::hooks::messages::NoteCollection* release_ncollection();
  void set_allocated_ncollection(::red::hooks::messages::NoteCollection* ncollection);
  ::red::hooks::messages::NoteCollection* unsafe_arena_release_ncollection();
  void unsafe_arena_set_allocated_ncollection(
      ::red::hooks::messages::NoteCollection* ncollection);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:red.hooks.messages.Response)
 private:
  inline void set_has_noteinfo();
  inline void set_has_note();
  inline void set_has_ncollection();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::uint32 status_;
  union PayloadUnion {
    PayloadUnion() {}
    ::red::hooks::messages::NoteInfo* noteinfo_;
    ::red::hooks::messages::Note* note_;
    ::red::hooks::messages::NoteCollection* ncollection_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_base_2eproto_impl();
  friend void  protobuf_AddDesc_base_2eproto_impl();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Response> Response_default_instance_;

// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:red.hooks.messages.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum PayloadCase {
    kNoteInfo = 1,
    kNote = 2,
    kNcollection = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static const Request* internal_default_instance();

  void UnsafeArenaSwap(Request* other);
  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  void UnsafeMergeFrom(const Request& from);
  protected:
  explicit Request(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .red.hooks.messages.RequestNoteInfo noteInfo = 1;
  bool has_noteinfo() const;
  void clear_noteinfo();
  static const int kNoteInfoFieldNumber = 1;
  private:
  void _slow_mutable_noteinfo();
  void _slow_set_allocated_noteinfo(
      ::google::protobuf::Arena* message_arena, ::red::hooks::messages::RequestNoteInfo** noteinfo);
  ::red::hooks::messages::RequestNoteInfo* _slow_release_noteinfo();
  public:
  const ::red::hooks::messages::RequestNoteInfo& noteinfo() const;
  ::red::hooks::messages::RequestNoteInfo* mutable_noteinfo();
  ::red::hooks::messages::RequestNoteInfo* release_noteinfo();
  void set_allocated_noteinfo(::red::hooks::messages::RequestNoteInfo* noteinfo);
  ::red::hooks::messages::RequestNoteInfo* unsafe_arena_release_noteinfo();
  void unsafe_arena_set_allocated_noteinfo(
      ::red::hooks::messages::RequestNoteInfo* noteinfo);

  // optional .red.hooks.messages.RequestNote note = 2;
  bool has_note() const;
  void clear_note();
  static const int kNoteFieldNumber = 2;
  private:
  void _slow_mutable_note();
  void _slow_set_allocated_note(
      ::google::protobuf::Arena* message_arena, ::red::hooks::messages::RequestNote** note);
  ::red::hooks::messages::RequestNote* _slow_release_note();
  public:
  const ::red::hooks::messages::RequestNote& note() const;
  ::red::hooks::messages::RequestNote* mutable_note();
  ::red::hooks::messages::RequestNote* release_note();
  void set_allocated_note(::red::hooks::messages::RequestNote* note);
  ::red::hooks::messages::RequestNote* unsafe_arena_release_note();
  void unsafe_arena_set_allocated_note(
      ::red::hooks::messages::RequestNote* note);

  // optional .red.hooks.messages.RequestNoteCollection ncollection = 3;
  bool has_ncollection() const;
  void clear_ncollection();
  static const int kNcollectionFieldNumber = 3;
  private:
  void _slow_mutable_ncollection();
  void _slow_set_allocated_ncollection(
      ::google::protobuf::Arena* message_arena, ::red::hooks::messages::RequestNoteCollection** ncollection);
  ::red::hooks::messages::RequestNoteCollection* _slow_release_ncollection();
  public:
  const ::red::hooks::messages::RequestNoteCollection& ncollection() const;
  ::red::hooks::messages::RequestNoteCollection* mutable_ncollection();
  ::red::hooks::messages::RequestNoteCollection* release_ncollection();
  void set_allocated_ncollection(::red::hooks::messages::RequestNoteCollection* ncollection);
  ::red::hooks::messages::RequestNoteCollection* unsafe_arena_release_ncollection();
  void unsafe_arena_set_allocated_ncollection(
      ::red::hooks::messages::RequestNoteCollection* ncollection);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:red.hooks.messages.Request)
 private:
  inline void set_has_noteinfo();
  inline void set_has_note();
  inline void set_has_ncollection();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    PayloadUnion() {}
    ::red::hooks::messages::RequestNoteInfo* noteinfo_;
    ::red::hooks::messages::RequestNote* note_;
    ::red::hooks::messages::RequestNoteCollection* ncollection_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_base_2eproto_impl();
  friend void  protobuf_AddDesc_base_2eproto_impl();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Request> Request_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Response

// optional uint32 status = 1;
inline void Response::clear_status() {
  status_ = 0u;
}
inline ::google::protobuf::uint32 Response::status() const {
  // @@protoc_insertion_point(field_get:red.hooks.messages.Response.status)
  return status_;
}
inline void Response::set_status(::google::protobuf::uint32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:red.hooks.messages.Response.status)
}

// optional .red.hooks.messages.NoteInfo noteInfo = 2;
inline bool Response::has_noteinfo() const {
  return payload_case() == kNoteInfo;
}
inline void Response::set_has_noteinfo() {
  _oneof_case_[0] = kNoteInfo;
}
inline void Response::clear_noteinfo() {
  if (has_noteinfo()) {
    if (GetArenaNoVirtual() == NULL) {
      delete payload_.noteinfo_;
    }
    clear_has_payload();
  }
}
inline  const ::red::hooks::messages::NoteInfo& Response::noteinfo() const {
  // @@protoc_insertion_point(field_get:red.hooks.messages.Response.noteInfo)
  return has_noteinfo()
      ? *payload_.noteinfo_
      : ::red::hooks::messages::NoteInfo::default_instance();
}
inline ::red::hooks::messages::NoteInfo* Response::mutable_noteinfo() {
  if (!has_noteinfo()) {
    clear_payload();
    set_has_noteinfo();
    payload_.noteinfo_ = 
      ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::NoteInfo >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:red.hooks.messages.Response.noteInfo)
  return payload_.noteinfo_;
}
inline ::red::hooks::messages::NoteInfo* Response::release_noteinfo() {
  // @@protoc_insertion_point(field_release:red.hooks.messages.Response.noteInfo)
  if (has_noteinfo()) {
    clear_has_payload();
    if (GetArenaNoVirtual() != NULL) {
      ::red::hooks::messages::NoteInfo* temp = new ::red::hooks::messages::NoteInfo(*payload_.noteinfo_);
      payload_.noteinfo_ = NULL;
      return temp;
    } else {
      ::red::hooks::messages::NoteInfo* temp = payload_.noteinfo_;
      payload_.noteinfo_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_noteinfo(::red::hooks::messages::NoteInfo* noteinfo) {
  clear_payload();
  if (noteinfo) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(noteinfo) == NULL) {
      GetArenaNoVirtual()->Own(noteinfo);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(noteinfo)) {
      ::red::hooks::messages::NoteInfo* new_noteinfo = 
          ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::NoteInfo >(
          GetArenaNoVirtual());
      new_noteinfo->CopyFrom(*noteinfo);
      noteinfo = new_noteinfo;
    }
    set_has_noteinfo();
    payload_.noteinfo_ = noteinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:red.hooks.messages.Response.noteInfo)
}
inline  ::red::hooks::messages::NoteInfo* Response::unsafe_arena_release_noteinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:red.hooks.messages.Response.noteInfo)
  if (has_noteinfo()) {
    clear_has_payload();
    ::red::hooks::messages::NoteInfo* temp = payload_.noteinfo_;
    payload_.noteinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Response::unsafe_arena_set_allocated_noteinfo(::red::hooks::messages::NoteInfo* noteinfo) {
  clear_payload();
  if (noteinfo) {
    set_has_noteinfo();
    payload_.noteinfo_ = noteinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:red.hooks.messages.Response.noteInfo)
}

// optional .red.hooks.messages.Note note = 3;
inline bool Response::has_note() const {
  return payload_case() == kNote;
}
inline void Response::set_has_note() {
  _oneof_case_[0] = kNote;
}
inline void Response::clear_note() {
  if (has_note()) {
    if (GetArenaNoVirtual() == NULL) {
      delete payload_.note_;
    }
    clear_has_payload();
  }
}
inline  const ::red::hooks::messages::Note& Response::note() const {
  // @@protoc_insertion_point(field_get:red.hooks.messages.Response.note)
  return has_note()
      ? *payload_.note_
      : ::red::hooks::messages::Note::default_instance();
}
inline ::red::hooks::messages::Note* Response::mutable_note() {
  if (!has_note()) {
    clear_payload();
    set_has_note();
    payload_.note_ = 
      ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::Note >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:red.hooks.messages.Response.note)
  return payload_.note_;
}
inline ::red::hooks::messages::Note* Response::release_note() {
  // @@protoc_insertion_point(field_release:red.hooks.messages.Response.note)
  if (has_note()) {
    clear_has_payload();
    if (GetArenaNoVirtual() != NULL) {
      ::red::hooks::messages::Note* temp = new ::red::hooks::messages::Note(*payload_.note_);
      payload_.note_ = NULL;
      return temp;
    } else {
      ::red::hooks::messages::Note* temp = payload_.note_;
      payload_.note_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_note(::red::hooks::messages::Note* note) {
  clear_payload();
  if (note) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(note) == NULL) {
      GetArenaNoVirtual()->Own(note);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(note)) {
      ::red::hooks::messages::Note* new_note = 
          ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::Note >(
          GetArenaNoVirtual());
      new_note->CopyFrom(*note);
      note = new_note;
    }
    set_has_note();
    payload_.note_ = note;
  }
  // @@protoc_insertion_point(field_set_allocated:red.hooks.messages.Response.note)
}
inline  ::red::hooks::messages::Note* Response::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_unsafe_arena_release:red.hooks.messages.Response.note)
  if (has_note()) {
    clear_has_payload();
    ::red::hooks::messages::Note* temp = payload_.note_;
    payload_.note_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Response::unsafe_arena_set_allocated_note(::red::hooks::messages::Note* note) {
  clear_payload();
  if (note) {
    set_has_note();
    payload_.note_ = note;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:red.hooks.messages.Response.note)
}

// optional .red.hooks.messages.NoteCollection ncollection = 4;
inline bool Response::has_ncollection() const {
  return payload_case() == kNcollection;
}
inline void Response::set_has_ncollection() {
  _oneof_case_[0] = kNcollection;
}
inline void Response::clear_ncollection() {
  if (has_ncollection()) {
    if (GetArenaNoVirtual() == NULL) {
      delete payload_.ncollection_;
    }
    clear_has_payload();
  }
}
inline  const ::red::hooks::messages::NoteCollection& Response::ncollection() const {
  // @@protoc_insertion_point(field_get:red.hooks.messages.Response.ncollection)
  return has_ncollection()
      ? *payload_.ncollection_
      : ::red::hooks::messages::NoteCollection::default_instance();
}
inline ::red::hooks::messages::NoteCollection* Response::mutable_ncollection() {
  if (!has_ncollection()) {
    clear_payload();
    set_has_ncollection();
    payload_.ncollection_ = 
      ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::NoteCollection >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:red.hooks.messages.Response.ncollection)
  return payload_.ncollection_;
}
inline ::red::hooks::messages::NoteCollection* Response::release_ncollection() {
  // @@protoc_insertion_point(field_release:red.hooks.messages.Response.ncollection)
  if (has_ncollection()) {
    clear_has_payload();
    if (GetArenaNoVirtual() != NULL) {
      ::red::hooks::messages::NoteCollection* temp = new ::red::hooks::messages::NoteCollection(*payload_.ncollection_);
      payload_.ncollection_ = NULL;
      return temp;
    } else {
      ::red::hooks::messages::NoteCollection* temp = payload_.ncollection_;
      payload_.ncollection_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_ncollection(::red::hooks::messages::NoteCollection* ncollection) {
  clear_payload();
  if (ncollection) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(ncollection) == NULL) {
      GetArenaNoVirtual()->Own(ncollection);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(ncollection)) {
      ::red::hooks::messages::NoteCollection* new_ncollection = 
          ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::NoteCollection >(
          GetArenaNoVirtual());
      new_ncollection->CopyFrom(*ncollection);
      ncollection = new_ncollection;
    }
    set_has_ncollection();
    payload_.ncollection_ = ncollection;
  }
  // @@protoc_insertion_point(field_set_allocated:red.hooks.messages.Response.ncollection)
}
inline  ::red::hooks::messages::NoteCollection* Response::unsafe_arena_release_ncollection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:red.hooks.messages.Response.ncollection)
  if (has_ncollection()) {
    clear_has_payload();
    ::red::hooks::messages::NoteCollection* temp = payload_.ncollection_;
    payload_.ncollection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Response::unsafe_arena_set_allocated_ncollection(::red::hooks::messages::NoteCollection* ncollection) {
  clear_payload();
  if (ncollection) {
    set_has_ncollection();
    payload_.ncollection_ = ncollection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:red.hooks.messages.Response.ncollection)
}

inline bool Response::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Response::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Response::PayloadCase Response::payload_case() const {
  return Response::PayloadCase(_oneof_case_[0]);
}
inline const Response* Response::internal_default_instance() {
  return &Response_default_instance_.get();
}
// -------------------------------------------------------------------

// Request

// optional .red.hooks.messages.RequestNoteInfo noteInfo = 1;
inline bool Request::has_noteinfo() const {
  return payload_case() == kNoteInfo;
}
inline void Request::set_has_noteinfo() {
  _oneof_case_[0] = kNoteInfo;
}
inline void Request::clear_noteinfo() {
  if (has_noteinfo()) {
    if (GetArenaNoVirtual() == NULL) {
      delete payload_.noteinfo_;
    }
    clear_has_payload();
  }
}
inline  const ::red::hooks::messages::RequestNoteInfo& Request::noteinfo() const {
  // @@protoc_insertion_point(field_get:red.hooks.messages.Request.noteInfo)
  return has_noteinfo()
      ? *payload_.noteinfo_
      : ::red::hooks::messages::RequestNoteInfo::default_instance();
}
inline ::red::hooks::messages::RequestNoteInfo* Request::mutable_noteinfo() {
  if (!has_noteinfo()) {
    clear_payload();
    set_has_noteinfo();
    payload_.noteinfo_ = 
      ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::RequestNoteInfo >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:red.hooks.messages.Request.noteInfo)
  return payload_.noteinfo_;
}
inline ::red::hooks::messages::RequestNoteInfo* Request::release_noteinfo() {
  // @@protoc_insertion_point(field_release:red.hooks.messages.Request.noteInfo)
  if (has_noteinfo()) {
    clear_has_payload();
    if (GetArenaNoVirtual() != NULL) {
      ::red::hooks::messages::RequestNoteInfo* temp = new ::red::hooks::messages::RequestNoteInfo(*payload_.noteinfo_);
      payload_.noteinfo_ = NULL;
      return temp;
    } else {
      ::red::hooks::messages::RequestNoteInfo* temp = payload_.noteinfo_;
      payload_.noteinfo_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_noteinfo(::red::hooks::messages::RequestNoteInfo* noteinfo) {
  clear_payload();
  if (noteinfo) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(noteinfo) == NULL) {
      GetArenaNoVirtual()->Own(noteinfo);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(noteinfo)) {
      ::red::hooks::messages::RequestNoteInfo* new_noteinfo = 
          ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::RequestNoteInfo >(
          GetArenaNoVirtual());
      new_noteinfo->CopyFrom(*noteinfo);
      noteinfo = new_noteinfo;
    }
    set_has_noteinfo();
    payload_.noteinfo_ = noteinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:red.hooks.messages.Request.noteInfo)
}
inline  ::red::hooks::messages::RequestNoteInfo* Request::unsafe_arena_release_noteinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:red.hooks.messages.Request.noteInfo)
  if (has_noteinfo()) {
    clear_has_payload();
    ::red::hooks::messages::RequestNoteInfo* temp = payload_.noteinfo_;
    payload_.noteinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Request::unsafe_arena_set_allocated_noteinfo(::red::hooks::messages::RequestNoteInfo* noteinfo) {
  clear_payload();
  if (noteinfo) {
    set_has_noteinfo();
    payload_.noteinfo_ = noteinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:red.hooks.messages.Request.noteInfo)
}

// optional .red.hooks.messages.RequestNote note = 2;
inline bool Request::has_note() const {
  return payload_case() == kNote;
}
inline void Request::set_has_note() {
  _oneof_case_[0] = kNote;
}
inline void Request::clear_note() {
  if (has_note()) {
    if (GetArenaNoVirtual() == NULL) {
      delete payload_.note_;
    }
    clear_has_payload();
  }
}
inline  const ::red::hooks::messages::RequestNote& Request::note() const {
  // @@protoc_insertion_point(field_get:red.hooks.messages.Request.note)
  return has_note()
      ? *payload_.note_
      : ::red::hooks::messages::RequestNote::default_instance();
}
inline ::red::hooks::messages::RequestNote* Request::mutable_note() {
  if (!has_note()) {
    clear_payload();
    set_has_note();
    payload_.note_ = 
      ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::RequestNote >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:red.hooks.messages.Request.note)
  return payload_.note_;
}
inline ::red::hooks::messages::RequestNote* Request::release_note() {
  // @@protoc_insertion_point(field_release:red.hooks.messages.Request.note)
  if (has_note()) {
    clear_has_payload();
    if (GetArenaNoVirtual() != NULL) {
      ::red::hooks::messages::RequestNote* temp = new ::red::hooks::messages::RequestNote(*payload_.note_);
      payload_.note_ = NULL;
      return temp;
    } else {
      ::red::hooks::messages::RequestNote* temp = payload_.note_;
      payload_.note_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_note(::red::hooks::messages::RequestNote* note) {
  clear_payload();
  if (note) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(note) == NULL) {
      GetArenaNoVirtual()->Own(note);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(note)) {
      ::red::hooks::messages::RequestNote* new_note = 
          ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::RequestNote >(
          GetArenaNoVirtual());
      new_note->CopyFrom(*note);
      note = new_note;
    }
    set_has_note();
    payload_.note_ = note;
  }
  // @@protoc_insertion_point(field_set_allocated:red.hooks.messages.Request.note)
}
inline  ::red::hooks::messages::RequestNote* Request::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_unsafe_arena_release:red.hooks.messages.Request.note)
  if (has_note()) {
    clear_has_payload();
    ::red::hooks::messages::RequestNote* temp = payload_.note_;
    payload_.note_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Request::unsafe_arena_set_allocated_note(::red::hooks::messages::RequestNote* note) {
  clear_payload();
  if (note) {
    set_has_note();
    payload_.note_ = note;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:red.hooks.messages.Request.note)
}

// optional .red.hooks.messages.RequestNoteCollection ncollection = 3;
inline bool Request::has_ncollection() const {
  return payload_case() == kNcollection;
}
inline void Request::set_has_ncollection() {
  _oneof_case_[0] = kNcollection;
}
inline void Request::clear_ncollection() {
  if (has_ncollection()) {
    if (GetArenaNoVirtual() == NULL) {
      delete payload_.ncollection_;
    }
    clear_has_payload();
  }
}
inline  const ::red::hooks::messages::RequestNoteCollection& Request::ncollection() const {
  // @@protoc_insertion_point(field_get:red.hooks.messages.Request.ncollection)
  return has_ncollection()
      ? *payload_.ncollection_
      : ::red::hooks::messages::RequestNoteCollection::default_instance();
}
inline ::red::hooks::messages::RequestNoteCollection* Request::mutable_ncollection() {
  if (!has_ncollection()) {
    clear_payload();
    set_has_ncollection();
    payload_.ncollection_ = 
      ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::RequestNoteCollection >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:red.hooks.messages.Request.ncollection)
  return payload_.ncollection_;
}
inline ::red::hooks::messages::RequestNoteCollection* Request::release_ncollection() {
  // @@protoc_insertion_point(field_release:red.hooks.messages.Request.ncollection)
  if (has_ncollection()) {
    clear_has_payload();
    if (GetArenaNoVirtual() != NULL) {
      ::red::hooks::messages::RequestNoteCollection* temp = new ::red::hooks::messages::RequestNoteCollection(*payload_.ncollection_);
      payload_.ncollection_ = NULL;
      return temp;
    } else {
      ::red::hooks::messages::RequestNoteCollection* temp = payload_.ncollection_;
      payload_.ncollection_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_ncollection(::red::hooks::messages::RequestNoteCollection* ncollection) {
  clear_payload();
  if (ncollection) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(ncollection) == NULL) {
      GetArenaNoVirtual()->Own(ncollection);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(ncollection)) {
      ::red::hooks::messages::RequestNoteCollection* new_ncollection = 
          ::google::protobuf::Arena::CreateMessage< ::red::hooks::messages::RequestNoteCollection >(
          GetArenaNoVirtual());
      new_ncollection->CopyFrom(*ncollection);
      ncollection = new_ncollection;
    }
    set_has_ncollection();
    payload_.ncollection_ = ncollection;
  }
  // @@protoc_insertion_point(field_set_allocated:red.hooks.messages.Request.ncollection)
}
inline  ::red::hooks::messages::RequestNoteCollection* Request::unsafe_arena_release_ncollection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:red.hooks.messages.Request.ncollection)
  if (has_ncollection()) {
    clear_has_payload();
    ::red::hooks::messages::RequestNoteCollection* temp = payload_.ncollection_;
    payload_.ncollection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Request::unsafe_arena_set_allocated_ncollection(::red::hooks::messages::RequestNoteCollection* ncollection) {
  clear_payload();
  if (ncollection) {
    set_has_ncollection();
    payload_.ncollection_ = ncollection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:red.hooks.messages.Request.ncollection)
}

inline bool Request::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Request::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Request::PayloadCase Request::payload_case() const {
  return Request::PayloadCase(_oneof_case_[0]);
}
inline const Request* Request::internal_default_instance() {
  return &Request_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace messages
}  // namespace hooks
}  // namespace red

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_2eproto__INCLUDED
